     8 |   try { return new Date().toISOString(); } catch { return "unknown"; }
     9 | }
    10 | function round(n: number) {
    11 |   return Math.round(Number.isFinite(n) ? n : 0);
    12 | }
    13 | 
    14 | function clampActivityFactor(x: number) {
    15 |   const min = 1.0;
    16 |   const max = 2.4;
    17 |   const raw = Number.isFinite(x) ? x : 0;
    18 |   const clamped = Math.min(max, Math.max(min, raw || min));
    19 |   return { min, max, raw, clamped, applied: clamped !== raw && Number.isFinite(raw) };
    20 | }
    21 | 
    22 | function computeActivityFactor(input: SSOTInputs, warnings: SSOTWarnings[]) {
    23 |   const explicit = input.activity?.activityFactor;
    24 |   if (Number.isFinite(explicit as number) && (explicit as number) > 0) {
    25 |     const c = clampActivityFactor(Number(explicit));
    26 |     if (c.applied) warnings.push({ code: "clamp_applied", message: `Clamp aplicado no fator de atividade (${c.raw}→${c.clamped}).` });
    27 |     return { activityFactor: c.clamped, raw: c.raw, source: "explicit" as const, clamp: c };
    28 |   }
    29 | 
    30 |   const freq = input.activity?.frequencyPerWeek;
    31 |   if (!freq) warnings.push({ code: "missing_freq", message: "Frequência semanal ausente. Usando fator padrão." });
    32 | 
    33 |   const f = Number(freq || 0);
    34 |   let base = 1.35;
    35 |   if (f >= 1 && f <= 2) base = 1.45;
    36 |   if (f >= 3 && f <= 4) base = 1.60;
    37 |   if (f >= 5 && f <= 6) base = 1.75;
    38 |   if (f >= 7) base = 1.90;
    39 | 
    40 |   warnings.push({ code: "fallback_used", message: "Fator de atividade por fallback (freq semanal). Refinaremos por modalidade na fase seguinte." });
    41 | 
    42 |   const c = clampActivityFactor(base);
    43 |   return { activityFactor: c.clamped, raw: c.raw, source: "fallback_freq" as const, clamp: c };
    44 | }
    45 | 
    46 | function normalizeGoal(g?: Goal): Goal | undefined {
    47 |   if (!g) return undefined;
    48 |   if (g === "cut" || g === "maintain" || g === "bulk") return g;
    49 |   return undefined;
    50 | }
    51 | 
    52 | export function computeSSOT(inputs: SSOTInputs): SSOTOutputs {
    53 |   const warnings: SSOTWarnings[] = [];
    54 | 
    55 |   const p = inputs.profile || {};
    56 |   const hasBase = Boolean(p.weightKg && p.heightCm && p.age);
    57 |   if (!hasBase) warnings.push({ code: "missing_profile", message: "Perfil incompleto (peso/altura/idade). SSOT calculou com defaults seguros." });
    58 | 
    59 |   const weightKg = Number(p.weightKg || 0);
    60 |   const heightCm = Number(p.heightCm || 0);
    61 |   const age = Number(p.age || 0);
    62 |   const sex = (p.sex || "unknown").toString();
    63 | 
    64 |   const ffm = Number(inputs.bodyComp?.ffmKg || 0);
    65 |   const athlete = Boolean(p.athlete);
    66 | 
    67 |   const auto = calculateREEAuto({
    68 |     pesoKg: weightKg,
    69 |     alturaCm: heightCm,
    70 |     idade: age,
    71 |     sexo: sex,
    72 |     massaMagraKg: ffm || undefined,
    73 |     athlete
    74 |   } as any);
    75 | 
    76 |   const ree = round((auto as any)?.reeKcal ?? (auto as any)?.ree ?? 0);
    77 |   const reeMethod = String((auto as any)?.method ?? (auto as any)?.equation ?? "auto");
    78 | 
    79 |   if (!ree || ree < 800 || ree > 4500) warnings.push({ code: "extreme_values", message: `REE fora do esperado (${ree}). Verifique peso/altura/idade.` });
    80 | 
    81 |   const act = computeActivityFactor(inputs, warnings);
    82 |   const tdee = round(ree * act.activityFactor);
    83 | 
    84 |   const goal = normalizeGoal(inputs.nutrition?.goal);
    85 |   let target = tdee;
    86 | 
    87 |   const pct = inputs.nutrition?.strategyPercent;
    88 |   if (typeof pct === "number" && Number.isFinite(pct)) {
    89 |     target = round(tdee * (1 + pct));
    90 |   } else if (goal) {
    91 |     const delta = objectiveDeltaKcal(goal as any, tdee);
    92 |     target = round(tdee + delta);
    93 |   }
    94 | 
    95 |   const floorMin = round(Math.max(ree * 1.05, 1200));
    96 |   const ceilMax = round(Math.min(tdee * 1.25, tdee + 900));
    97 |   const ideal = target;
    98 |   const safeMin =  round(Math.max(Math.min(ideal, floorMin), floorMin));
    99 |   const safeMax = round(Math.max(ideal, Math.max(ideal, ceilMax)));
   100 | 
   101 |   let targetFinal = ideal;
   102 |   if (targetFinal < safeMin) {
   103 |     warnings.push({ code: "clamp_applied", message: `Target ajustado para faixa segura (${targetFinal}→${safeMin}).` });
   104 |     targetFinal = safeMin;
   105 |   }
   106 |   if (targetFinal > safeMax) {
   107 |     warnings.push({ code: "clamp_applied", message: `Target ajustado para faixa segura (${targetFinal}→${safeMax}).` });
   108 |     targetFinal = safeMax;
   109 |   }
   110 | 
   111 |   const trace = {
   112 |     timestamp: nowIso(),
   113 |     storageKey: STORAGE_KEY,
   114 |     reeMethod,
   115 |     reeKcal: ree,
   116 |     activityFactorRaw: act.raw,
   117 |     activityFactorFinal: act.activityFactor,
   118 |     tdeeKcal: tdee,
   119 |     goal,
   120 |     targetKcal: targetFinal,
   121 |     clamp: { min: act.clamp.min, max: act.clamp.max, applied: act.clamp.applied }
   122 |   };
   123 | 
   124 |   return {
   125 |     metabolic: { reeKcal: ree, activityFactor: act.activityFactor, tdeeKcal: tdee },
   126 |     nutrition: { targetKcal: targetFinal },
   127 |     safeRange: { min: safeMin, ideal: targetFinal, max: safeMax },
   128 |     audit: { trace, warnings }
   129 |   };
   130 | }
